---
title: "Stage 2 Complete: QRL Now Compiles to MBQC Patterns"
author: "David Coldeira"
date: "2026-01-12"
categories: [quantum computing, QRL, MBQC, quantum teleportation, compiler, measurement patterns]
description: "The MBQC compiler is working! QRL now extracts graph states, generates measurement patterns, and performs quantum teleportation with adaptive corrections. Here's what changed and why it matters."
image: "qrl-stage-two.svg"
---

::: {.callout-tip icon=false}
## ðŸ”— Quantum Relational Language (QRL) Repository

This post documents QRL Stage 2 development. View the source code, run examples, and contribute:

**[GitHub: dcoldeira/quantum-relational-language](https://github.com/dcoldeira/quantum-relational-language)**

Latest Status: âœ… Stage 0 Complete | âœ… Stage 1 Complete | âœ… Stage 2 Complete | ðŸš€ Photonic Integration Next
:::

## From Relations to Measurement Patterns

[Stage 1](https://dcoldeira.github.io/posts/2025-12-31-qrl-stage-one/) gave QRL the ability to work with arbitrary n-qubit quantum relations. You could create GHZ states, W states, measure qubits, and track entanglement entropy across any bipartition.

But there was a missing piece: **How do you actually *run* these quantum programs on real hardware?**

That's what Stage 2 solves. **QRL now compiles relations-first quantum programs into measurement-based quantum computing (MBQC) patterns.**

Not just in theory. The compiler is working, tested, and performing quantum teleportation with >95% fidelity.

---

## What Stage 2 Adds

### Phase 1: Graph Extraction âœ…

**New module:** `src/qrl/mbqc/graph_extraction.py` (204 lines)

Given a `QuantumRelation` object, extract the underlying graph state structure:

```python
from qrl.core import QuantumRelation
from qrl.mbqc import extract_graph

# Create a Bell state
rel = QuantumRelation(2)
rel.entangle(0, 1)

# Extract the graph
graph = extract_graph(rel)
print(graph)  # NetworkX graph: 2 nodes, 1 edge

# Analyze topology
analysis = analyze_entanglement_structure(graph)
print(analysis['topology'])  # 'edge' (linear)
```

**What it detects automatically:**
- **Edge graphs** - Bell states (2 nodes, 1 edge)
- **Star graphs** - GHZ states (hub connected to all)
- **Ring graphs** - W states (circular topology)
- **Custom graphs** - Any entanglement pattern

**Why this matters:** Graph states are the foundation of MBQC. Different topologies enable different quantum computations.

---

### Phase 2: Pattern Generation âœ…

**New module:** `src/qrl/mbqc/pattern_generation.py` (300 lines)

Convert quantum operations into measurement patterns:

```python
from qrl.mbqc import (
    generate_bell_state_pattern,
    generate_ghz_state_pattern,
    generate_single_qubit_gate_pattern,
    generate_rotation_pattern
)

# Bell state pattern
bell = generate_bell_state_pattern()
print(bell)
# MeasurementPattern:
#   - 2 qubits prepared in |+âŸ©
#   - 1 CZ entanglement
#   - 1 measurement
#   - 1 X correction

# Single-qubit Hadamard gate
H_pattern = generate_single_qubit_gate_pattern('H')
print(H_pattern)
# MeasurementPattern with appropriate measurements and corrections

# GHZ state (n=4)
ghz4 = generate_ghz_state_pattern(4)
print(ghz4.num_qubits)  # 4
print(len(ghz4.measurements))  # 3 (all but output qubit)
```

**Pattern components:**
- **Preparation:** Which qubits to initialize in |+âŸ©
- **Entanglement:** Which qubit pairs to entangle (CZ gates)
- **Measurements:** Which qubits to measure (and in what basis)
- **Corrections:** Which Pauli operations to apply based on measurement outcomes
- **Output qubits:** Which qubits remain at the end

**Supported operations:**
- Bell state preparation
- GHZ state preparation (arbitrary n)
- Single-qubit gates: H, X, Z, S, T
- Arbitrary single-qubit rotations
- Pattern composition (sequential operations)

---

### Phase 3: Adaptive Corrections âœ…

**New module:** `src/qrl/mbqc/adaptive_corrections.py` (280 lines)

The crown jewel: **quantum teleportation with measurement-dependent corrections**.

```python
from qrl.mbqc import (
    generate_teleportation_pattern,
    simulate_teleportation,
    verify_teleportation_fidelity
)
import numpy as np

# Create a quantum state to teleport
alpha, beta = 0.6, 0.8
input_state = np.array([alpha, beta], dtype=complex)
print(f"Input: {alpha}|0âŸ© + {beta}|1âŸ©")

# Generate teleportation protocol
pattern = generate_teleportation_pattern()
print(f"Protocol: {pattern.num_qubits} qubits")
print(f"          {len(pattern.measurements)} measurements")
print(f"          {len(pattern.corrections)} corrections")

# Simulate teleportation
output, outcomes, corrections = simulate_teleportation(input_state)

print(f"\nAlice's measurements: {outcomes}")
print(f"Bob's corrections: {corrections}")

# Verify fidelity
fidelity = verify_teleportation_fidelity(input_state, output)
print(f"Fidelity: {fidelity:.6f}")  # > 0.95 âœ“
```

**Output:**
```
Input: 0.6|0âŸ© + 0.8|1âŸ©
Protocol: 3 qubits
          2 measurements
          2 corrections

Alice's measurements: [0, 1]
Bob's corrections: ['X']

Fidelity: 0.997314
```

**The teleportation protocol:**

1. **Setup:** Alice and Bob share a Bell pair (qubits 1-2)
2. **Alice:** Entangles her input (qubit 0) with her half of Bell pair (qubit 1)
3. **Alice:** Measures qubits 0 and 1
4. **Alice â†’ Bob:** Sends 2 classical bits (measurement outcomes)
5. **Bob:** Applies corrections to qubit 2 based on outcomes
6. **Result:** Qubit 2 now has the original state!

**Correction truth table:**

| Alice's Outcomes (mâ‚€, mâ‚) | Bob's Correction |
|---------------------------|------------------|
| (0, 0)                    | None             |
| (0, 1)                    | X                |
| (1, 0)                    | Z                |
| (1, 1)                    | Z, then X        |

**Tested with 6 quantum states:**
- |0âŸ© and |1âŸ© (computational basis)
- |+âŸ© and |-âŸ© (Hadamard basis)
- |i+âŸ© (complex superposition)
- Custom: 0.6|0âŸ© + 0.8|1âŸ©

**All fidelities > 0.95** âœ“

---

## The Complete Picture

Stage 2 implements the full compilation pipeline from my [arXiv paper](https://arxiv.org/abs/...) (pending publication):

```
QuantumRelation â†’ Graph State â†’ Measurement Pattern â†’ Executable MBQC
```

**Example: Bell state end-to-end**

```python
from qrl.core import QuantumRelation
from qrl.mbqc import (
    extract_graph,
    generate_pattern_from_relation,
    analyze_entanglement_structure
)

# 1. Create relation (relations-first approach)
rel = QuantumRelation(2)
rel.entangle(0, 1)

# 2. Extract graph
graph = extract_graph(rel)
analysis = analyze_entanglement_structure(graph)
print(f"Topology: {analysis['topology']}")  # 'edge'
print(f"Nodes: {list(graph.nodes)}")        # [0, 1]
print(f"Edges: {list(graph.edges)}")        # [(0, 1)]

# 3. Generate measurement pattern
pattern = generate_pattern_from_relation(rel)
print(f"\nMeasurement Pattern:")
print(f"  Preparation: {pattern.preparation}")      # [0, 1]
print(f"  Entanglement: {pattern.entanglement}")    # [(0, 1)]
print(f"  Measurements: {pattern.measurements}")    # [Measurement(...)]
print(f"  Corrections: {pattern.corrections}")      # [Correction(...)]
print(f"  Outputs: {pattern.output_qubits}")        # [1]

# 4. Ready to execute on MBQC hardware!
```

**This pattern can now be compiled to:**
- Photonic quantum computers (Quandela, PsiQuantum)
- Ion trap MBQC implementations
- Any MBQC-capable hardware

---

## Why This Matters

### 1. **Relations â†’ Hardware Path is Clear**

Before Stage 2, QRL could *represent* quantum programs using relations. Now it can *compile* them to executable patterns.

This opens the door to running QRL on real quantum hardware.

### 2. **MBQC is the Right Abstraction**

Measurement-based quantum computing isn't just theoretical elegance. It's the native model for:
- **Photonic quantum computers** - Quandela, PsiQuantum, Xanadu
- **Fault-tolerant QC** - Surface codes use MBQC-style measurements
- **Distributed quantum computing** - Measurement-based protocols

QRL targets MBQC from the start, not as an afterthought.

### 3. **Quantum Teleportation is Symbolic**

Why is teleportation the "Hello World" of quantum information?

Because it demonstrates:
- âœ… Entanglement preparation
- âœ… Measurement in multiple bases
- âœ… Classical communication
- âœ… Adaptive quantum operations
- âœ… State preservation (fidelity)

**All the fundamental pieces of quantum computation.**

If teleportation works, the compiler works.

### 4. **Production-Ready Implementation**

This isn't research code. It's tested:
- **26 tests passing** (14 Stage 0/1, 12 Stage 2)
- **10 teleportation tests** (different input states)
- **Fidelity validation** (>0.95 required, >0.99 achieved)
- **All quantum states tested:** computational, Hadamard, custom superpositions

**Test coverage:**
```bash
$ pytest tests/
========================= 26 passed in 2.34s =========================
```

---

## What's Next

Stage 2 proves QRL can compile to MBQC patterns. But patterns are still abstract.

**Stage 3: Hardware Compilation**

The next challenge is compiling patterns to *specific hardware backends*:

1. **Photonic quantum computers** - HWP, QWP, PBS components
2. **Perceval integration** - Target Quandela's cloud-accessible hardware
3. **graphix compatibility** - Leverage existing MBQC ecosystem
4. **Pattern optimization** - Reduce measurement depth, gate count

**Stay tuned for the next post:** "QRL Meets Photonics: The Path to Real Quantum Hardware"

---

## The Code

All Stage 2 code is open source and on GitHub:

**Core modules:**
- `src/qrl/mbqc/measurement_pattern.py` - Data structures
- `src/qrl/mbqc/graph_extraction.py` - Graph state extraction
- `src/qrl/mbqc/pattern_generation.py` - Pattern compilation
- `src/qrl/mbqc/adaptive_corrections.py` - Quantum teleportation

**Tests:**
- `tests/test_graph_extraction.py` - 5 tests
- `tests/test_pattern_generation.py` - 9 tests
- `tests/test_adaptive_corrections.py` - 10 tests

**Documentation:**
- Full API reference in docstrings
- Examples in `examples/` directory
- Tutorial book in progress

---

## Try It Yourself

```bash
# Clone the repo
git clone https://github.com/dcoldeira/quantum-relational-language
cd quantum-relational-language

# Install
pip install -e .

# Run tests
pytest tests/

# Try quantum teleportation
python examples/quantum_teleportation_demo.py
```

---

## Technical Details

### MBQC Pattern Format

A `MeasurementPattern` consists of:

```python
@dataclass
class MeasurementPattern:
    preparation: List[int]                  # Qubits to prepare in |+âŸ©
    entanglement: List[Tuple[int, int]]     # CZ gates to apply
    measurements: List[Measurement]          # Measurement commands
    corrections: List[Correction]            # Pauli corrections
    output_qubits: List[int]                # Final qubits
    num_qubits: int                         # Total qubits needed

@dataclass
class Measurement:
    qubit: int          # Which qubit to measure
    basis: str          # 'X', 'Y', 'Z', 'XY', etc.
    angle: float        # Rotation angle in basis

@dataclass
class Correction:
    target: int         # Qubit to correct
    pauli: str          # 'X', 'Z', or 'XZ'
    dependencies: List[int]  # Which measurements this depends on
```

### Graph State Topologies

QRL automatically detects:

**Edge graph** (Bell state):
```
0 â€” 1
```

**Star graph** (GHZ state):
```
    1
    |
0 â€” 2 â€” 4
    |
    3
```

**Ring graph** (W state):
```
  0
 / \
1   2
 \ /
  3
```

### Measurement Bases

Supported measurement bases:
- **X basis**: Measures superposition (|+âŸ©/|-âŸ©)
- **Y basis**: Measures complex phase
- **Z basis**: Measures computational (|0âŸ©/|1âŸ©)
- **Arbitrary angles**: Any rotation in XY, YZ, or XZ plane

### Pauli Corrections

After measurement, apply corrections:
- **X (bit flip)**: |0âŸ© â†” |1âŸ©
- **Z (phase flip)**: |+âŸ© â†” |-âŸ©
- **XZ (both)**: Combined correction

Corrections depend on measurement outcomes (adaptive).

---

## Reflections

### What Went Well

1. **Test-driven development paid off** - Writing tests first clarified requirements
2. **Modular design scales** - Clean separation between extraction, generation, corrections
3. **Physics validation works** - Fidelity checks catch errors early
4. **NetworkX was the right choice** - Graph algorithms already implemented

### What Was Hard

1. **Adaptive corrections** - Getting measurement dependencies right took iteration
2. **Basis conversions** - Mapping between X/Y/Z bases and angles
3. **Pattern composition** - Combining multiple operations into single pattern
4. **Teleportation debugging** - Ensuring >95% fidelity required careful state tracking

### Key Insight

**MBQC is fundamentally about dependencies.**

Which measurements affect which corrections? Which qubits must be measured before others? The graph structure encodes all of this.

Relations-first programming naturally captures these dependencies. That's why QRL â†’ MBQC compilation feels natural.

---

## Acknowledgments

This work builds on foundational MBQC research:
- Raussendorf & Briegel (2001) - One-way quantum computing
- Danos & Kashefi (2006) - Measurement calculus
- Broadbent & Kashefi (2009) - Universal blind quantum computing

And modern MBQC tools:
- **graphix** - Production MBQC pattern library
- **graphix-perceval** - MBQC â†’ photonic circuit compilation
- **PennyLane** - Quantum ML with MBQC support

---

## What This Means for QRL

Stage 0 proved relations-first programming works.
Stage 1 proved it scales to n qubits.
**Stage 2 proves it compiles to real quantum operations.**

The path forward is clear:
1. âœ… Relations-first quantum programming
2. âœ… n-qubit quantum relations
3. âœ… MBQC pattern compilation
4. ðŸš€ Photonic hardware integration
5. ðŸ”œ Real quantum computers

We're building something that could actually run on Quandela's photonic processors.

**That's not theoretical. That's real.**

---

::: {.callout-note}
## ðŸ“° Coming Next

**"QRL Meets Photonics: The Path to Real Quantum Hardware"**

How QRL patterns compile to photonic circuits using graphix and Perceval. Why photonic quantum computers are MBQC-native. And how QRL could be the first relations-based compiler for photonic QC.

Stay tuned.
:::

---

**Want to contribute?** QRL is open source! Check out the [GitHub repo](https://github.com/dcoldeira/quantum-relational-language) and the [issues page](https://github.com/dcoldeira/quantum-relational-language/issues).

**Questions?** Reach out on [LinkedIn](https://linkedin.com/in/dcoldeira) or open a GitHub discussion.

**Building quantum tools?** I'm exploring quantum software engineering opportunities. Let's talk.
