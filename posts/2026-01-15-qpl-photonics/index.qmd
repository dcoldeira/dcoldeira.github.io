---
title: "QRL Meets Photonics: The First Relations-Based Compiler for Photonic Quantum Computers"
author: "David Coldeira"
date: "2026-01-15"
categories: [quantum computing, QRL, photonic QC, MBQC, Quandela, Perceval, graphix, hardware]
description: "Photonic quantum computers are MBQC-native. QRL's relations-first approach compiles directly to photonic circuits, bypassing gate decomposition entirely. This changes everything."
image: "qpl-photonics.svg"
---

::: {.callout-tip icon=false}
## üîó Quantum Relational Language (QRL) Repository

This post explores QRL's path to real quantum hardware. View the source code and contribute:

**[GitHub: dcoldeira/quantum-relational-language](https://github.com/dcoldeira/quantum-relational-language)**

Latest Status: ‚úÖ Stage 2 Complete | üöÄ Photonic Integration In Progress
:::

## The Hardware Problem

You've built a quantum programming language. It can represent entanglement, compile to MBQC patterns, and perform quantum teleportation. The physics is correct, the tests pass, the fidelity is high.

**But can it run on real quantum hardware?**

That's the question that matters. Because without hardware, quantum programming languages are just elegant mathematics.

For QRL, the answer isn't just "yes." It's **"photonic quantum computers were designed for this."**

Here's why.

---

## Two Paths to Quantum Computing

The quantum computing world has largely standardized on one paradigm:

**The Gate Model:**
1. Initialize qubits in |0‚ü©
2. Apply unitary gates (H, CNOT, T, etc.)
3. Measure at the end
4. Classical post-processing

**Hardware:** Superconducting qubits (IBM, Google), ion traps (IonQ, Quantinuum)

This works. But it's not the only way.

**The MBQC Model:**
1. Prepare large entangled cluster state
2. Measure individual qubits adaptively
3. Computation happens through measurement
4. Corrections depend on measurement outcomes

**Hardware:** Photonic quantum computers (Quandela, PsiQuantum, Xanadu)

**Here's the key insight:** Photonic quantum computing is *MBQC-native*.

Not as an add-on. Not as a compilation target. As the fundamental model of computation.

---

## Why Photonics Loves MBQC

### 1. **Photons Are Easy to Entangle**

Creating cluster states in photonics:
- **HWP** (half-wave plate) - Prepare |+‚ü© states
- **PBS** (polarizing beam splitter) - Entangle photons
- **Linear optics** - Standard, well-understood components

**In superconducting systems?** You need precisely calibrated two-qubit gates with error rates <1%. Every gate is a potential failure point.

**In photonic systems?** You generate entanglement probabilistically using linear optics. Post-select on success. No calibration needed.

### 2. **Measurements Are Natural**

Measuring photons:
- Photon detectors are mature technology
- Single-photon detection is routine
- No readout errors from qubit decoherence
- Measurements are destructive (photons are consumed)

**This matches MBQC perfectly.** In MBQC, qubits are *supposed* to be measured and consumed. That's the model.

### 3. **No Decoherence During Computation**

**Superconducting qubits:** T‚ÇÅ ~ 100 Œºs, T‚ÇÇ ~ 50 Œºs
Gates must execute before decoherence destroys quantum states.

**Photons:** T‚ÇÅ = ‚àû (photons don't decay)
Photons maintain quantum state during propagation. Decoherence only happens at measurement.

**MBQC takes advantage of this:** Generate cluster state once, then measure adaptively. No time pressure.

### 4. **Room Temperature Operation**

**Superconducting qubits:** 10 mK dilution refrigerators
**Photonic qubits:** Room temperature

**Scaling advantage:** More refrigerators vs more photonics. Guess which is easier?

---

## The Traditional Compilation Problem

Most quantum languages target the gate model:

```
High-Level Code ‚Üí Gates (H, CNOT, T) ‚Üí Circuit ‚Üí Transpile ‚Üí Hardware
```

**If your hardware is photonic MBQC:**

```
High-Level Code ‚Üí Gates ‚Üí Circuit ‚Üí Decompose to MBQC ‚Üí Resource graphs ‚Üí Photonic circuit
```

**That's four compilation steps!** Each introducing overhead, approximations, and complexity.

**Languages doing this today:**
- Qiskit (IBM) - Gates first, MBQC as backend
- Cirq (Google) - Gates first, no MBQC
- Q# (Microsoft) - Gates first, abstract hardware
- Silq - Gates first, academic

**They're fighting against the hardware model.**

---

## The QRL Approach

QRL doesn't compile *to* MBQC. **QRL *is* MBQC.**

```
Relations ‚Üí Graph States ‚Üí Measurement Patterns ‚Üí Photonic Circuits
```

**Two steps instead of four.** No gate decomposition. No circuit synthesis. No transpilation overhead.

**Why?** Because relations naturally encode the *entanglement structure* that MBQC needs.

**Example: Bell State**

**Traditional approach:**
```python
# Qiskit (gate model)
qc = QuantumCircuit(2)
qc.h(0)           # Hadamard on qubit 0
qc.cx(0, 1)       # CNOT from 0 to 1
qc.measure_all()

# Now decompose to MBQC...
# Then compile to photonics...
```

**QRL approach:**
```python
# QRL (relations-first)
rel = QuantumRelation(2)
rel.entangle(0, 1)  # Express the relationship directly

# Extract graph state
graph = extract_graph(rel)  # 2 nodes, 1 edge

# Generate MBQC pattern
pattern = generate_pattern_from_relation(rel)

# Compile to photonics (2 steps, not 4)
```

**The difference:** We never went through gates. We expressed what we wanted (entanglement between qubits 0 and 1), and the compiler figured out how to implement it on MBQC hardware.

---

## Entering the Ecosystem: graphix

When I started exploring photonic compilation, I discovered **graphix** - a production-ready MBQC pattern library from the TeamGraphix project.

**graphix provides:**
- Pattern data structure (nodes, edges, measurements, corrections)
- Pattern simulation
- Pattern optimization
- ZX-calculus integration
- Active development and community

**Most importantly:** graphix-perceval exists - a bridge from MBQC patterns to Perceval (Quandela's photonic simulator).

**This means the path exists:** graphix Pattern ‚Üí Perceval Circuit ‚Üí Quandela Hardware

---

## Understanding graphix Patterns

graphix uses a command-based approach:

**Commands:**
- `N(node)` - Prepare qubit in |+‚ü©
- `E(nodes=[i,j])` - Entangle qubits i and j (CZ gate)
- `M(node, plane, angle, ...)` - Measure qubit
- `X(node, domain=[...])` - Apply X correction based on measurements
- `Z(node, domain=[...])` - Apply Z correction based on measurements

**Example Bell state in graphix:**
```
N(0) N(1) E(0,1) M(0) X(1,{0})
```

**Translation:**
1. Prepare qubits 0 and 1 in |+‚ü©
2. Entangle them with CZ
3. Measure qubit 0 in X basis
4. Apply X correction to qubit 1 if qubit 0 measured 1

**That's it.** Five commands. Bell state prepared.

---

## QRL ‚Üî graphix Compatibility

I analyzed the data structures:

**QRL MeasurementPattern:**
```python
class MeasurementPattern:
    preparation: List[int]              # Qubits to prepare
    entanglement: List[Tuple[int,int]]  # CZ pairs
    measurements: List[Measurement]      # Measurement commands
    corrections: List[Correction]        # Pauli corrections
    output_qubits: List[int]            # Final qubits
```

**graphix Pattern:**
```python
class Pattern:
    input_nodes: List[int]      # Input qubits
    output_nodes: List[int]     # Output qubits
    n_node: int                 # Total nodes
    # Commands accessed via methods
```

**Compatibility analysis:** ~80% structural overlap

**Mapping:**
```
QRL preparation[i]         ‚Üí graphix N(node=i)
QRL entanglement[(i,j)]    ‚Üí graphix E(nodes=[i,j])
QRL measurements[k]        ‚Üí graphix M(node=k, plane, angle, ...)
QRL corrections[c]         ‚Üí graphix X/Z(node, domain)
```

**This is implementable.** We can write a converter: `qpl_to_graphix()`.

---

## The graphix-perceval Pipeline

I cloned and studied graphix-perceval's source code. Here's how it works:

### Step 1: Extract Graph State

```python
graph_state, phasedict, output_nodes = pattern2graphstate(pattern)
```

Extract the underlying graph state structure from the pattern.

### Step 2: Decompose into Resource Graphs

```python
ResourceGraphs = get_fusion_network_from_graph(graph_state)
```

Break the graph state into standard resource states:
- **GHZ type:** Star topology (hub connected to all)
- **Linear type:** Chain topology (path graph)

**Why?** Because these have known photonic implementations!

### Step 3: Generate Photonic Circuits

**GHZ Resource State (n photons):**
```python
for i in range(n):
    circuit.add(i, HWP(œÄ/8))  # Prepare |+‚ü©

for i in range(n-1):
    circuit.add((i, i+1), PBS())  # Entangle via PBS

for i in range(1, n):
    circuit.add(i, HWP(œÄ/8))  # Hadamard on all but first
```

**Linear Resource State (n photons):**
```python
for i in range(n):
    circuit.add(i, HWP(œÄ/8))  # Prepare |+‚ü©

for i in range(n-1):
    circuit.add((i, i+1), PBS())  # Chain entanglement
    if i >= 1 and i != n-2:
        circuit.add(i+1, HWP(œÄ/8))

circuit.add(0, HWP(œÄ/8))  # Boundary
circuit.add(n-1, HWP(œÄ/8))
```

### Step 4: Fuse Resource Graphs

**Type-1 Fusion:**
```python
circuit.add((ph1, ph2), PBS())
circuit.add(ph2, HWP(œÄ/8))
```

Connect two resource graphs by fusing photons at shared nodes.

### Step 5: Apply Measurements

Convert measurement basis using wave plates:
```python
circuit.add(qubit, QWP(angle))  # Quarter-wave plate
circuit.add(qubit, HWP(angle))  # Half-wave plate
circuit.add(qubit, PBS())        # Measure via PBS
```

### Step 6: Convert to Path Encoding

Quandela uses **dual-rail path encoding:**
- Qubit |0‚ü© = photon in mode 0: `|1,0‚ü©`
- Qubit |1‚ü© = photon in mode 1: `|0,1‚ü©`

**2 modes per qubit**
n qubits = 2n photonic modes

**Conversion:** PBS converts polarization encoding ‚Üí path encoding

---

## Photonic Components Explained

**HWP (Half-Wave Plate):**
- Rotates polarization
- Implements single-qubit rotations
- Œ∏ = œÄ/8 gives Hadamard gate
- Passive linear optics (no energy needed)

**QWP (Quarter-Wave Plate):**
- œÄ/2 rotation
- Creates superpositions
- Changes measurement basis
- Also passive linear optics

**PBS (Polarizing Beam Splitter):**
- Splits H and V polarization
- Implements CZ gate in polarization encoding
- Standard measurement device
- Photon detection at outputs

**Why linear optics?**
- **Scalable:** Just mirrors, beam splitters, wave plates
- **Room temperature:** No cryogenics
- **Well-understood:** Classical optics + single photons
- **Manufacturable:** Integrated photonic chips

---

## The Full Compilation Pipeline

**QRL ‚Üí Quandela Hardware (proposed):**

```python
# 1. Create relation (QRL)
rel = QuantumRelation(2)
rel.entangle(0, 1)

# 2. Compile to MBQC pattern (Stage 2 ‚úÖ)
qpl_pattern = generate_pattern_from_relation(rel)

# 3. Convert to graphix pattern (Next: implement converter)
graphix_pattern = qpl_to_graphix(qpl_pattern)

# 4. Compile to Perceval circuit (graphix-perceval)
perceval_circuit = graphix_perceval.to_perceval(graphix_pattern)

# 5. Run on Perceval simulator
from perceval import Processor
processor = Processor("SLOS", perceval_circuit)
results = processor.sample(100)

# 6. Eventually: Run on Quandela Cloud
processor = Processor("Quandela:Belenos", perceval_circuit)
results = processor.sample(100)  # Real photonic quantum computer!
```

**Status:**
- ‚úÖ Step 1-2: Working (Stage 2 complete)
- üöß Step 3: Next to implement
- ‚úÖ Step 4-5: graphix-perceval exists (studied source code)
- ‚è≥ Step 6: Quandela Cloud access (will apply)

---

## Why This Matters

### 1. **First Relations-Based Photonic Compiler**

No other quantum language compiles from relations ‚Üí MBQC ‚Üí photonics.

**Qiskit?** Gates ‚Üí circuits ‚Üí MBQC transpiler (if you write it)
**Cirq?** Gates ‚Üí circuits (no MBQC)
**Strawberry Fields?** Continuous variables (different model)
**QRL?** Relations ‚Üí MBQC natively

**This is the differentiator.**

### 2. **Industry Relevance**

Photonic quantum computing is heating up:

**PsiQuantum** - $665M funding, building fault-tolerant photonic QC
**Quandela** - Belenos (12 qubits) accessible in 2025, Canopus (~24 qubits) in 2026
**Xanadu** - Borealis (216 squeezed modes), PennyLane ecosystem
**ORCA Computing** - Photonic QC in London

**These companies need MBQC tools.** QRL targets their hardware natively.

### 3. **Competitive Advantage Over Gate-Based Languages**

**For photonic hardware:**

Gate-based languages must:
1. Decompose gates ‚Üí circuits
2. Synthesize circuits ‚Üí MBQC patterns
3. Compile patterns ‚Üí resource graphs
4. Generate photonic circuits
5. Handle approximation errors at each step

QRL must:
1. Extract graph states from relations
2. Generate photonic circuits

**Two steps vs five.** Less overhead, fewer errors, better performance.

### 4. **It's Not Theoretical - It's Implementable**

- ‚úÖ graphix exists (production MBQC library)
- ‚úÖ graphix-perceval exists (MBQC ‚Üí Perceval bridge)
- ‚úÖ Perceval exists (Quandela's simulator/hardware interface)
- ‚úÖ Quandela hardware exists (12-qubit Belenos accessible)
- ‚úÖ QRL ‚Üí graphix mapping is ~80% compatible

**All the pieces exist.** We're connecting them, not inventing them.

---

## Technical Deep Dive: Resource-Based Compilation

Why does graphix-perceval decompose into GHZ and Linear resource states?

### GHZ States Are Photonic-Native

**GHZ state:** (|000...‚ü© + |111...‚ü©)/‚àö2

**Star graph topology:**
```
    1
    |
0 ‚Äî 2 ‚Äî 4
    |
    3
```

**Photonic implementation:**
1. Prepare all photons in |+‚ü© (HWP)
2. Apply PBS between hub and all spokes
3. Apply Hadamard (HWP) to all spokes

**This is a standard photonic protocol!**

### Linear Cluster States Are Scalable

**Linear cluster:** 1D chain of entangled qubits

**Graph topology:**
```
0 ‚Äî 1 ‚Äî 2 ‚Äî 3 ‚Äî 4
```

**Photonic implementation:**
1. Prepare all photons in |+‚ü© (HWP)
2. Apply PBS between adjacent photons
3. Boundary Hadamards on ends

**Also a standard protocol.**

### Why These Two?

**Because photonic implementations exist:**
- Published in academic papers
- Experimentally validated
- Implemented in commercial systems
- Stable and reproducible

**Any graph state can be decomposed into GHZ + Linear resources.**

That's why graphix-perceval uses this approach.

---

## The Path Forward

**Immediate (Next 2 weeks):**

1. **Implement QRL ‚Üí graphix converter**
   - Create `qpl/backends/graphix_adapter.py`
   - Map QRL MeasurementPattern ‚Üí graphix Pattern
   - Handle basis conversions
   - Write tests

2. **Validate on known patterns**
   - Bell state: QRL ‚Üí graphix ‚Üí simulate
   - GHZ states: QRL ‚Üí graphix ‚Üí simulate
   - Teleportation: QRL ‚Üí graphix ‚Üí simulate
   - Verify fidelity matches

3. **Study resource graph extraction**
   - Understand graphix's `get_fusion_network_from_graph()`
   - See how it decomposes arbitrary graphs
   - This is key for photonic compilation

**Short term (1-2 months):**

4. **Perceval integration (Python 3.11 venv)**
   - graphix-perceval requires Python <3.12
   - Create separate venv with Python 3.11
   - Test full pipeline: QRL ‚Üí graphix ‚Üí Perceval
   - Run on Perceval simulator

5. **First photonic simulation**
   - Bell state: QRL ‚Üí graphix ‚Üí Perceval ‚Üí simulate
   - Validate fidelity
   - **Milestone:** First QRL program on photonic backend!

6. **Apply for Quandela Cloud access**
   - Show QRL ‚Üí Perceval working
   - Request access to Belenos (12 qubits)
   - Prepare for real hardware run

**Medium term (3-6 months):**

7. **First QRL program on real photonic QPU**
   - Run on Quandela Cloud
   - Bell state on real photonic quantum computer
   - Benchmark results
   - **Major milestone!**

8. **Paper update**
   - Add Perceval integration section
   - Include photonic compilation pipeline
   - Report hardware results
   - Potentially submit to photonic QC journals

9. **Industry outreach**
   - Contact Quandela about collaboration
   - Reach out to PsiQuantum research team
   - Explore QRL as research tool for photonic QC
   - Apply to quantum software engineering positions

---

## Comparison: QRL vs Existing Tools

| Feature | QRL | Qiskit | Cirq | Strawberry Fields | graphix |
|---------|-----|--------|------|-------------------|---------|
| **MBQC native** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚ö†Ô∏è CV only | ‚úÖ Yes |
| **Relations-first** | ‚úÖ Yes | ‚ùå Gates | ‚ùå Gates | ‚ùå Gates | ‚ùå Graphs |
| **Photonic target** | ‚úÖ Yes | ‚ùå Superconducting | ‚ùå Superconducting | ‚úÖ Yes (CV) | ‚úÖ Yes (DV) |
| **Perceval integration** | üöß In progress | ‚ùå No | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Discrete variables** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | ‚ùå CV only | ‚úÖ Yes |
| **Pattern optimization** | ‚è≥ Future | ‚ùå N/A | ‚ùå N/A | ‚ùå N/A | ‚úÖ Yes |
| **Hardware tested** | ‚è≥ Soon | ‚úÖ IBM | ‚úÖ Google | ‚úÖ Xanadu | ‚úÖ Quandela |

**Key insights:**
- **Qiskit/Cirq** - Excellent for superconducting, not MBQC-native
- **Strawberry Fields** - Photonic but continuous-variable (different model)
- **graphix** - MBQC-native but graph-first (not relations-first)
- **QRL** - Only relations-first + MBQC-native + photonic-targeting language

---

## Industry Positioning

**What QRL offers to photonic QC companies:**

1. **Higher-level abstraction than gates**
   Express quantum programs as relationships, not circuits

2. **Native MBQC compilation**
   No gate decomposition overhead

3. **Photonic-first thinking**
   Designed for measurement-based hardware from day one

4. **Open source ecosystem integration**
   Works with graphix, Perceval, Quandela tools

5. **Research-backed**
   arXiv paper (pending publication) documenting approach

**Target companies:**
- **Quandela** (Paris) - Perceval integration, Belenos/Canopus hardware
- **PsiQuantum** (Palo Alto/London) - Fault-tolerant photonic QC
- **Xanadu** (Toronto) - PennyLane integration potential
- **ORCA Computing** (London) - UK-based photonic QC

**Pitch:** "The first relations-based MBQC compiler for photonic quantum computers"

---

## What Makes This Different

Most quantum languages are **gate-centric**:
- Start with gates (H, CNOT, T)
- Build circuits
- Optimize circuits
- Compile to hardware

**QRL is relation-centric:**
- Start with relationships (entangle, measure)
- Extract graph structure
- Generate measurement patterns
- Compile to hardware

**For gate-based hardware (superconducting)?** Gate-centric wins.

**For MBQC-based hardware (photonic)?** Relation-centric wins.

**That's the thesis.**

---

## Honest Evaluation

### What's Working

- ‚úÖ Relations-first approach is sound
- ‚úÖ MBQC compilation pipeline works (Stage 2 complete)
- ‚úÖ Quantum teleportation validates adaptive corrections
- ‚úÖ graphix ecosystem is mature and production-ready
- ‚úÖ Perceval ‚Üí Quandela path exists
- ‚úÖ Photonic QC industry is growing rapidly

### What's Still Needed

- ‚è≥ QRL ‚Üí graphix converter (next to implement)
- ‚è≥ Perceval integration testing
- ‚è≥ Python 3.11 environment (graphix-perceval requirement)
- ‚è≥ Quandela Cloud access
- ‚è≥ Real hardware validation
- ‚è≥ Performance benchmarks vs gate-based approaches

### Open Questions

1. **How does compilation overhead compare?**
   Relations ‚Üí MBQC vs Gates ‚Üí MBQC

2. **What's the resource count?**
   Qubits, measurements, corrections for equivalent programs

3. **Can we optimize patterns?**
   Reduce measurement depth, parallelize operations

4. **How does it scale?**
   10 qubits? 50 qubits? 100 qubits?

**These need empirical testing on real patterns.**

---

## Try It Yourself

**Explore graphix:**
```bash
# Install graphix
pip install graphix[extra]

# Run the exploration script
cd quantum-relational-language
python examples/graphix_exploration.py
```

**Output:**
```
‚úì graphix imported successfully
======================================
BELL STATE PATTERN (graphix)
======================================
Pattern commands:
N(0) N(1) E(0,1) M(0) X(1,{0})

Pattern summary:
  Nodes: 2
  Input nodes: []
  Output nodes: [1]

‚úì Exploration complete!
```

---

## The Vision

**Short term:** QRL programs compile to graphix patterns
**Medium term:** graphix patterns compile to Perceval circuits
**Long term:** Perceval circuits run on Quandela hardware

**The full stack:**
```
QRL Code
   ‚Üì
Relations
   ‚Üì
MBQC Patterns
   ‚Üì
graphix Patterns
   ‚Üì
Perceval Circuits
   ‚Üì
Quandela Hardware
```

**This isn't science fiction. Every piece exists.**

We're building the glue.

---

## For Researchers

**If you work on:**
- Photonic quantum computing
- MBQC theory or implementation
- Quantum programming languages
- Quantum compiler optimization

**QRL might be relevant to your work.**

**Collaboration opportunities:**
- Benchmark QRL vs gate-based compilation
- Optimize patterns for photonic hardware
- Extend to continuous-variable systems
- Fault-tolerant MBQC compilation
- Hardware-specific optimizations

**Contact:** Open a GitHub issue or reach out directly.

---

## For Industry

**If you're building:**
- Photonic quantum computers
- MBQC-based systems
- Quantum software tools
- Quantum compilers

**QRL demonstrates an alternative approach.**

**Not production-ready yet.** But the path is clear:
1. Relations-first programming model
2. Native MBQC compilation
3. Photonic hardware targeting
4. Open source ecosystem integration

**Interested in collaborating?** Let's talk.

---

## What's Next

**The next post will show the implementation:**

"Building the QRL ‚Üí graphix Converter: Connecting Relations to Photonics"

- Implementation details
- Code walkthrough
- Validation results
- First simulated photonic circuits

**Until then:** The code is on GitHub, the research is ongoing, and photonic quantum computing is accelerating.

**We're building something that could run on real quantum computers in 2026.**

That's not a dream. That's a roadmap.

---

::: {.callout-important}
## üöÄ Join the Journey

QRL is open source and actively developed:

- **Contribute:** [GitHub Issues](https://github.com/dcoldeira/quantum-relational-language/issues)
- **Discuss:** [GitHub Discussions](https://github.com/dcoldeira/quantum-relational-language/discussions)
- **Connect:** [LinkedIn](https://linkedin.com/in/dcoldeira)
- **Follow:** New blog posts every 1-2 weeks

**Building quantum tools? Let's collaborate.**
:::

---

## References

**MBQC Foundations:**
- Raussendorf & Briegel (2001) - "A one-way quantum computer"
- Danos & Kashefi (2006) - "The measurement calculus"

**Photonic QC:**
- Kok et al. (2007) - "Linear optical quantum computing"
- Rudolph (2017) - "Why I am optimistic about the silicon-photonic route to quantum computing"

**Tools:**
- **graphix** - https://github.com/TeamGraphix/graphix
- **graphix-perceval** - https://github.com/TeamGraphix/graphix-perceval
- **Perceval** - https://perceval.quandela.net/
- **Quandela** - https://www.quandela.com/

**Companies:**
- **Quandela** - Photonic quantum computers (France)
- **PsiQuantum** - Fault-tolerant photonic QC (USA/UK)
- **Xanadu** - Photonic QC and PennyLane (Canada)
- **ORCA Computing** - Photonic QC (UK)
